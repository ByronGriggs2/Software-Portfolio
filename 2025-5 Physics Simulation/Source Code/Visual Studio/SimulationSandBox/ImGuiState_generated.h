// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IMGUISTATE_NET_H_
#define FLATBUFFERS_GENERATED_IMGUISTATE_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace net {

struct Matrix4x4ImGui;

struct ImGuiState;
struct ImGuiStateBuilder;

enum IntegrationType : int32_t {
  IntegrationType_euler = 0,
  IntegrationType_semi_euler = 1,
  IntegrationType_MIN = IntegrationType_euler,
  IntegrationType_MAX = IntegrationType_semi_euler
};

inline const IntegrationType (&EnumValuesIntegrationType())[2] {
  static const IntegrationType values[] = {
    IntegrationType_euler,
    IntegrationType_semi_euler
  };
  return values;
}

inline const char * const *EnumNamesIntegrationType() {
  static const char * const names[3] = {
    "euler",
    "semi_euler",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntegrationType(IntegrationType e) {
  if (::flatbuffers::IsOutRange(e, IntegrationType_euler, IntegrationType_semi_euler)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntegrationType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix4x4ImGui FLATBUFFERS_FINAL_CLASS {
 private:
  float m_[16];

 public:
  Matrix4x4ImGui()
      : m_() {
  }
  Matrix4x4ImGui(::flatbuffers::span<const float, 16> _m) {
    ::flatbuffers::CastToArray(m_).CopyFromSpan(_m);
  }
  const ::flatbuffers::Array<float, 16> *m() const {
    return &::flatbuffers::CastToArray(m_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix4x4ImGui, 64);

struct ImGuiState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImGuiStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTING_RESET = 4,
    VT_NEW_DATA = 6,
    VT_TARGET_RENDER_FREQUENCY = 8,
    VT_TARGET_SIMULATION_FREQUENCY = 10,
    VT_TARGET_NETWORK_FREQUENCY = 12,
    VT_CURRENT_SCENARIO_INDEX = 14,
    VT_PAUSED = 16,
    VT_GRAVITY_ON = 18,
    VT_GRAVITY_INVERTED = 20,
    VT_TIMESTEP = 22,
    VT_BACKGROUND_COLOR = 24,
    VT_INTEGRATION_TYPE = 26,
    VT_CAMERA_POSITION_OFFSET = 28,
    VT_CAMERA_ROTATION_OFFSET = 30
  };
  bool requesting_reset() const {
    return GetField<uint8_t>(VT_REQUESTING_RESET, 0) != 0;
  }
  bool new_data() const {
    return GetField<uint8_t>(VT_NEW_DATA, 0) != 0;
  }
  int32_t target_render_frequency() const {
    return GetField<int32_t>(VT_TARGET_RENDER_FREQUENCY, 0);
  }
  int32_t target_simulation_frequency() const {
    return GetField<int32_t>(VT_TARGET_SIMULATION_FREQUENCY, 0);
  }
  int32_t target_network_frequency() const {
    return GetField<int32_t>(VT_TARGET_NETWORK_FREQUENCY, 0);
  }
  int32_t current_scenario_index() const {
    return GetField<int32_t>(VT_CURRENT_SCENARIO_INDEX, 0);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool gravity_on() const {
    return GetField<uint8_t>(VT_GRAVITY_ON, 0) != 0;
  }
  bool gravity_inverted() const {
    return GetField<uint8_t>(VT_GRAVITY_INVERTED, 0) != 0;
  }
  float timestep() const {
    return GetField<float>(VT_TIMESTEP, 0.0f);
  }
  const ::flatbuffers::Vector<float> *background_color() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BACKGROUND_COLOR);
  }
  net::IntegrationType integration_type() const {
    return static_cast<net::IntegrationType>(GetField<int32_t>(VT_INTEGRATION_TYPE, 0));
  }
  const ::flatbuffers::Vector<float> *camera_position_offset() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CAMERA_POSITION_OFFSET);
  }
  const net::Matrix4x4ImGui *camera_rotation_offset() const {
    return GetStruct<const net::Matrix4x4ImGui *>(VT_CAMERA_ROTATION_OFFSET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTING_RESET, 1) &&
           VerifyField<uint8_t>(verifier, VT_NEW_DATA, 1) &&
           VerifyField<int32_t>(verifier, VT_TARGET_RENDER_FREQUENCY, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_SIMULATION_FREQUENCY, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NETWORK_FREQUENCY, 4) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_SCENARIO_INDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_GRAVITY_ON, 1) &&
           VerifyField<uint8_t>(verifier, VT_GRAVITY_INVERTED, 1) &&
           VerifyField<float>(verifier, VT_TIMESTEP, 4) &&
           VerifyOffset(verifier, VT_BACKGROUND_COLOR) &&
           verifier.VerifyVector(background_color()) &&
           VerifyField<int32_t>(verifier, VT_INTEGRATION_TYPE, 4) &&
           VerifyOffset(verifier, VT_CAMERA_POSITION_OFFSET) &&
           verifier.VerifyVector(camera_position_offset()) &&
           VerifyField<net::Matrix4x4ImGui>(verifier, VT_CAMERA_ROTATION_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct ImGuiStateBuilder {
  typedef ImGuiState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_requesting_reset(bool requesting_reset) {
    fbb_.AddElement<uint8_t>(ImGuiState::VT_REQUESTING_RESET, static_cast<uint8_t>(requesting_reset), 0);
  }
  void add_new_data(bool new_data) {
    fbb_.AddElement<uint8_t>(ImGuiState::VT_NEW_DATA, static_cast<uint8_t>(new_data), 0);
  }
  void add_target_render_frequency(int32_t target_render_frequency) {
    fbb_.AddElement<int32_t>(ImGuiState::VT_TARGET_RENDER_FREQUENCY, target_render_frequency, 0);
  }
  void add_target_simulation_frequency(int32_t target_simulation_frequency) {
    fbb_.AddElement<int32_t>(ImGuiState::VT_TARGET_SIMULATION_FREQUENCY, target_simulation_frequency, 0);
  }
  void add_target_network_frequency(int32_t target_network_frequency) {
    fbb_.AddElement<int32_t>(ImGuiState::VT_TARGET_NETWORK_FREQUENCY, target_network_frequency, 0);
  }
  void add_current_scenario_index(int32_t current_scenario_index) {
    fbb_.AddElement<int32_t>(ImGuiState::VT_CURRENT_SCENARIO_INDEX, current_scenario_index, 0);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ImGuiState::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_gravity_on(bool gravity_on) {
    fbb_.AddElement<uint8_t>(ImGuiState::VT_GRAVITY_ON, static_cast<uint8_t>(gravity_on), 0);
  }
  void add_gravity_inverted(bool gravity_inverted) {
    fbb_.AddElement<uint8_t>(ImGuiState::VT_GRAVITY_INVERTED, static_cast<uint8_t>(gravity_inverted), 0);
  }
  void add_timestep(float timestep) {
    fbb_.AddElement<float>(ImGuiState::VT_TIMESTEP, timestep, 0.0f);
  }
  void add_background_color(::flatbuffers::Offset<::flatbuffers::Vector<float>> background_color) {
    fbb_.AddOffset(ImGuiState::VT_BACKGROUND_COLOR, background_color);
  }
  void add_integration_type(net::IntegrationType integration_type) {
    fbb_.AddElement<int32_t>(ImGuiState::VT_INTEGRATION_TYPE, static_cast<int32_t>(integration_type), 0);
  }
  void add_camera_position_offset(::flatbuffers::Offset<::flatbuffers::Vector<float>> camera_position_offset) {
    fbb_.AddOffset(ImGuiState::VT_CAMERA_POSITION_OFFSET, camera_position_offset);
  }
  void add_camera_rotation_offset(const net::Matrix4x4ImGui *camera_rotation_offset) {
    fbb_.AddStruct(ImGuiState::VT_CAMERA_ROTATION_OFFSET, camera_rotation_offset);
  }
  explicit ImGuiStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImGuiState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImGuiState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImGuiState> CreateImGuiState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool requesting_reset = false,
    bool new_data = false,
    int32_t target_render_frequency = 0,
    int32_t target_simulation_frequency = 0,
    int32_t target_network_frequency = 0,
    int32_t current_scenario_index = 0,
    bool paused = false,
    bool gravity_on = false,
    bool gravity_inverted = false,
    float timestep = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> background_color = 0,
    net::IntegrationType integration_type = net::IntegrationType_euler,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> camera_position_offset = 0,
    const net::Matrix4x4ImGui *camera_rotation_offset = nullptr) {
  ImGuiStateBuilder builder_(_fbb);
  builder_.add_camera_rotation_offset(camera_rotation_offset);
  builder_.add_camera_position_offset(camera_position_offset);
  builder_.add_integration_type(integration_type);
  builder_.add_background_color(background_color);
  builder_.add_timestep(timestep);
  builder_.add_current_scenario_index(current_scenario_index);
  builder_.add_target_network_frequency(target_network_frequency);
  builder_.add_target_simulation_frequency(target_simulation_frequency);
  builder_.add_target_render_frequency(target_render_frequency);
  builder_.add_gravity_inverted(gravity_inverted);
  builder_.add_gravity_on(gravity_on);
  builder_.add_paused(paused);
  builder_.add_new_data(new_data);
  builder_.add_requesting_reset(requesting_reset);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImGuiState> CreateImGuiStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool requesting_reset = false,
    bool new_data = false,
    int32_t target_render_frequency = 0,
    int32_t target_simulation_frequency = 0,
    int32_t target_network_frequency = 0,
    int32_t current_scenario_index = 0,
    bool paused = false,
    bool gravity_on = false,
    bool gravity_inverted = false,
    float timestep = 0.0f,
    const std::vector<float> *background_color = nullptr,
    net::IntegrationType integration_type = net::IntegrationType_euler,
    const std::vector<float> *camera_position_offset = nullptr,
    const net::Matrix4x4ImGui *camera_rotation_offset = nullptr) {
  auto background_color__ = background_color ? _fbb.CreateVector<float>(*background_color) : 0;
  auto camera_position_offset__ = camera_position_offset ? _fbb.CreateVector<float>(*camera_position_offset) : 0;
  return net::CreateImGuiState(
      _fbb,
      requesting_reset,
      new_data,
      target_render_frequency,
      target_simulation_frequency,
      target_network_frequency,
      current_scenario_index,
      paused,
      gravity_on,
      gravity_inverted,
      timestep,
      background_color__,
      integration_type,
      camera_position_offset__,
      camera_rotation_offset);
}

inline const net::ImGuiState *GetImGuiState(const void *buf) {
  return ::flatbuffers::GetRoot<net::ImGuiState>(buf);
}

inline const net::ImGuiState *GetSizePrefixedImGuiState(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<net::ImGuiState>(buf);
}

inline bool VerifyImGuiStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<net::ImGuiState>(nullptr);
}

inline bool VerifySizePrefixedImGuiStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<net::ImGuiState>(nullptr);
}

inline void FinishImGuiStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<net::ImGuiState> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedImGuiStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<net::ImGuiState> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace net

#endif  // FLATBUFFERS_GENERATED_IMGUISTATE_NET_H_
