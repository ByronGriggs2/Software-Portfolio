// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMEOBJECT_NET_H_
#define FLATBUFFERS_GENERATED_GAMEOBJECT_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace net {

struct SimpleVertex;
struct SimpleVertexBuilder;

struct BufferData;
struct BufferDataBuilder;

struct Matrix4x4;

struct GameObject;
struct GameObjectBuilder;

enum ObjType : int32_t {
  ObjType_capsule = 0,
  ObjType_cylinder = 1,
  ObjType_hollowCube = 2,
  ObjType_plane = 3,
  ObjType_sphere = 4,
  ObjType_physObj = 5,
  ObjType_MIN = ObjType_capsule,
  ObjType_MAX = ObjType_physObj
};

inline const ObjType (&EnumValuesObjType())[6] {
  static const ObjType values[] = {
    ObjType_capsule,
    ObjType_cylinder,
    ObjType_hollowCube,
    ObjType_plane,
    ObjType_sphere,
    ObjType_physObj
  };
  return values;
}

inline const char * const *EnumNamesObjType() {
  static const char * const names[7] = {
    "capsule",
    "cylinder",
    "hollowCube",
    "plane",
    "sphere",
    "physObj",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjType(ObjType e) {
  if (::flatbuffers::IsOutRange(e, ObjType_capsule, ObjType_physObj)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjType()[index];
}

enum StaticPtrPreset : int32_t {
  StaticPtrPreset_def = 0,
  StaticPtrPreset_texture = 1,
  StaticPtrPreset_MIN = StaticPtrPreset_def,
  StaticPtrPreset_MAX = StaticPtrPreset_texture
};

inline const StaticPtrPreset (&EnumValuesStaticPtrPreset())[2] {
  static const StaticPtrPreset values[] = {
    StaticPtrPreset_def,
    StaticPtrPreset_texture
  };
  return values;
}

inline const char * const *EnumNamesStaticPtrPreset() {
  static const char * const names[3] = {
    "def",
    "texture",
    nullptr
  };
  return names;
}

inline const char *EnumNameStaticPtrPreset(StaticPtrPreset e) {
  if (::flatbuffers::IsOutRange(e, StaticPtrPreset_def, StaticPtrPreset_texture)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStaticPtrPreset()[index];
}

enum PeerColor : int32_t {
  PeerColor_undef = 0,
  PeerColor_red = 1,
  PeerColor_yellow = 2,
  PeerColor_green = 3,
  PeerColor_blue = 4,
  PeerColor_MIN = PeerColor_undef,
  PeerColor_MAX = PeerColor_blue
};

inline const PeerColor (&EnumValuesPeerColor())[5] {
  static const PeerColor values[] = {
    PeerColor_undef,
    PeerColor_red,
    PeerColor_yellow,
    PeerColor_green,
    PeerColor_blue
  };
  return values;
}

inline const char * const *EnumNamesPeerColor() {
  static const char * const names[6] = {
    "undef",
    "red",
    "yellow",
    "green",
    "blue",
    nullptr
  };
  return names;
}

inline const char *EnumNamePeerColor(PeerColor e) {
  if (::flatbuffers::IsOutRange(e, PeerColor_undef, PeerColor_blue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPeerColor()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix4x4 FLATBUFFERS_FINAL_CLASS {
 private:
  float m_[16];

 public:
  Matrix4x4()
      : m_() {
  }
  Matrix4x4(::flatbuffers::span<const float, 16> _m) {
    ::flatbuffers::CastToArray(m_).CopyFromSpan(_m);
  }
  const ::flatbuffers::Array<float, 16> *m() const {
    return &::flatbuffers::CastToArray(m_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix4x4, 64);

struct SimpleVertex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SimpleVertexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_NORM = 6,
    VT_TEX = 8
  };
  const ::flatbuffers::Vector<float> *pos() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POS);
  }
  const ::flatbuffers::Vector<float> *norm() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_NORM);
  }
  const ::flatbuffers::Vector<float> *tex() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TEX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(pos()) &&
           VerifyOffset(verifier, VT_NORM) &&
           verifier.VerifyVector(norm()) &&
           VerifyOffset(verifier, VT_TEX) &&
           verifier.VerifyVector(tex()) &&
           verifier.EndTable();
  }
};

struct SimpleVertexBuilder {
  typedef SimpleVertex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pos(::flatbuffers::Offset<::flatbuffers::Vector<float>> pos) {
    fbb_.AddOffset(SimpleVertex::VT_POS, pos);
  }
  void add_norm(::flatbuffers::Offset<::flatbuffers::Vector<float>> norm) {
    fbb_.AddOffset(SimpleVertex::VT_NORM, norm);
  }
  void add_tex(::flatbuffers::Offset<::flatbuffers::Vector<float>> tex) {
    fbb_.AddOffset(SimpleVertex::VT_TEX, tex);
  }
  explicit SimpleVertexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SimpleVertex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SimpleVertex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SimpleVertex> CreateSimpleVertex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pos = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> norm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> tex = 0) {
  SimpleVertexBuilder builder_(_fbb);
  builder_.add_tex(tex);
  builder_.add_norm(norm);
  builder_.add_pos(pos);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SimpleVertex> CreateSimpleVertexDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *pos = nullptr,
    const std::vector<float> *norm = nullptr,
    const std::vector<float> *tex = nullptr) {
  auto pos__ = pos ? _fbb.CreateVector<float>(*pos) : 0;
  auto norm__ = norm ? _fbb.CreateVector<float>(*norm) : 0;
  auto tex__ = tex ? _fbb.CreateVector<float>(*tex) : 0;
  return net::CreateSimpleVertex(
      _fbb,
      pos__,
      norm__,
      tex__);
}

struct BufferData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTEX_DATA = 4,
    VT_INDEX_DATA = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<net::SimpleVertex>> *vertex_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<net::SimpleVertex>> *>(VT_VERTEX_DATA);
  }
  const ::flatbuffers::Vector<uint16_t> *index_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_INDEX_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTEX_DATA) &&
           verifier.VerifyVector(vertex_data()) &&
           verifier.VerifyVectorOfTables(vertex_data()) &&
           VerifyOffset(verifier, VT_INDEX_DATA) &&
           verifier.VerifyVector(index_data()) &&
           verifier.EndTable();
  }
};

struct BufferDataBuilder {
  typedef BufferData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vertex_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<net::SimpleVertex>>> vertex_data) {
    fbb_.AddOffset(BufferData::VT_VERTEX_DATA, vertex_data);
  }
  void add_index_data(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> index_data) {
    fbb_.AddOffset(BufferData::VT_INDEX_DATA, index_data);
  }
  explicit BufferDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BufferData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BufferData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BufferData> CreateBufferData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<net::SimpleVertex>>> vertex_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> index_data = 0) {
  BufferDataBuilder builder_(_fbb);
  builder_.add_index_data(index_data);
  builder_.add_vertex_data(vertex_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BufferData> CreateBufferDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<net::SimpleVertex>> *vertex_data = nullptr,
    const std::vector<uint16_t> *index_data = nullptr) {
  auto vertex_data__ = vertex_data ? _fbb.CreateVector<::flatbuffers::Offset<net::SimpleVertex>>(*vertex_data) : 0;
  auto index_data__ = index_data ? _fbb.CreateVector<uint16_t>(*index_data) : 0;
  return net::CreateBufferData(
      _fbb,
      vertex_data__,
      index_data__);
}

struct GameObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UID = 4,
    VT_TYPE = 6,
    VT_ORIENTATION = 8,
    VT_PTR_TYPE = 10,
    VT_INDEX_COUNT = 12,
    VT_COLOR = 14,
    VT_BUFFER = 16
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  net::ObjType type() const {
    return static_cast<net::ObjType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const net::Matrix4x4 *orientation() const {
    return GetStruct<const net::Matrix4x4 *>(VT_ORIENTATION);
  }
  net::StaticPtrPreset ptr_type() const {
    return static_cast<net::StaticPtrPreset>(GetField<int32_t>(VT_PTR_TYPE, 0));
  }
  int32_t index_count() const {
    return GetField<int32_t>(VT_INDEX_COUNT, 0);
  }
  net::PeerColor color() const {
    return static_cast<net::PeerColor>(GetField<int32_t>(VT_COLOR, 0));
  }
  const net::BufferData *buffer() const {
    return GetPointer<const net::BufferData *>(VT_BUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<net::Matrix4x4>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<int32_t>(verifier, VT_PTR_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_INDEX_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_COLOR, 4) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyTable(buffer()) &&
           verifier.EndTable();
  }
};

struct GameObjectBuilder {
  typedef GameObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(GameObject::VT_UID, uid, 0);
  }
  void add_type(net::ObjType type) {
    fbb_.AddElement<int32_t>(GameObject::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_orientation(const net::Matrix4x4 *orientation) {
    fbb_.AddStruct(GameObject::VT_ORIENTATION, orientation);
  }
  void add_ptr_type(net::StaticPtrPreset ptr_type) {
    fbb_.AddElement<int32_t>(GameObject::VT_PTR_TYPE, static_cast<int32_t>(ptr_type), 0);
  }
  void add_index_count(int32_t index_count) {
    fbb_.AddElement<int32_t>(GameObject::VT_INDEX_COUNT, index_count, 0);
  }
  void add_color(net::PeerColor color) {
    fbb_.AddElement<int32_t>(GameObject::VT_COLOR, static_cast<int32_t>(color), 0);
  }
  void add_buffer(::flatbuffers::Offset<net::BufferData> buffer) {
    fbb_.AddOffset(GameObject::VT_BUFFER, buffer);
  }
  explicit GameObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameObject> CreateGameObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    net::ObjType type = net::ObjType_capsule,
    const net::Matrix4x4 *orientation = nullptr,
    net::StaticPtrPreset ptr_type = net::StaticPtrPreset_def,
    int32_t index_count = 0,
    net::PeerColor color = net::PeerColor_undef,
    ::flatbuffers::Offset<net::BufferData> buffer = 0) {
  GameObjectBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_color(color);
  builder_.add_index_count(index_count);
  builder_.add_ptr_type(ptr_type);
  builder_.add_orientation(orientation);
  builder_.add_type(type);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline const net::GameObject *GetGameObject(const void *buf) {
  return ::flatbuffers::GetRoot<net::GameObject>(buf);
}

inline const net::GameObject *GetSizePrefixedGameObject(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<net::GameObject>(buf);
}

inline bool VerifyGameObjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<net::GameObject>(nullptr);
}

inline bool VerifySizePrefixedGameObjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<net::GameObject>(nullptr);
}

inline void FinishGameObjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<net::GameObject> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGameObjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<net::GameObject> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace net

#endif  // FLATBUFFERS_GENERATED_GAMEOBJECT_NET_H_
